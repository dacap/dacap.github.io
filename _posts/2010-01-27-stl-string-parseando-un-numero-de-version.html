---
layout: post
title: STL string, parseando un número de versión
date: 2010-01-27
category: cpp
tags: [cpp, programacion, parser, string]
---

<div class='post'>
En esta ocasión vamos a ver cómo usar la clase <em>std::string</em> para convertir una cadena de caracteres (como "1.2.3") en una clase "Version" que tenga una interfaz simple de utilizar (por ejemplo, que permita comparar versiones).<br /><br />Los pasos son simples:<br /><ol><li>tenemos como entrada una cadena de caracteres,<br /></li><li>dividimos la cadena según el caracter '.' (punto),<br /></li><li>convertimos cada parte a entero,<br /></li><li>guardamos cada número entero de forma ordenada en un vector.<br /></li></ol>El punto 2 es en el cual nos vamos a enfocar más. <em>El código mostrado aquí es a modo de ejemplo, y está lejos de ser el más óptimo.</em><br /><br /><b>Antes de comenzar ¿Podemos usar <a href="http://www.cplusplus.com/reference/clibrary/cstring/strcmp/">strcmp</a> para comparar dos versiones?</b> No, no podemos. Ejemplo: strcmp("1.9", "1.10") &gt; 0, cuando en realidad la versión 1.9 es menor a 1.10.<br /><br />Imaginemos que tenemos una cadena: <br /><pre class="prettyprint">std::string ver = "1.10.2.3";<br /></pre>La clase <a href="http://www.cplusplus.com/reference/string/string/">std::string</a> tiene la función miembro <a href="http://www.cplusplus.com/reference/string/string/find/">find</a>, la cual podemos usar para buscar casi cualquier cosa dentro de la cadena. ¿Qué debemos buscar? Los puntos, sabiendo donde está cada punto, podemos ir recortando la cadena en sus distintas partes ("1", "10", "2", y "3"). Buscamos la ubicación del primer punto: <br /><pre class="prettyprint">size_t i = ver.find('.');<br /><br />if (i != std::string::npos)<br />  std::printf("El punto fue encontrado en la posición %d\n", i);<br />else<br />  std::printf("No hay punto en la cadena\n");<br /></pre>Ejecutando el código anterior, deberíamos obtener el mensaje: <br /><pre>El punto fue encontrado en la posición 1<br /></pre><b>¿Qué es <a href="http://www.cplusplus.com/reference/clibrary/cstring/size_t/">size_t</a>?</b> Es como el tipo "unsigned int", el tipo de dato retornado por el operador <a href="http://www.cppreference.com/wiki/keywords/sizeof">sizeof()</a> y utilizado como índice en las funciones de std::string.<br /><br /><b>¿Qué es <a href="http://www.cplusplus.com/reference/string/string/npos/">std::string::npos</a>?</b> Es el máximo valor posible de un <em>size_t</em> y se utiliza para indicar (en este caso) que la función <em>find</em> falló (no encontró el punto).<br /><br />Una vez que tenemos la posición del punto, podemos obtener la porción de texto que contiene la primer cifra, para eso usamos la función miembro <a href="http://www.cplusplus.com/reference/string/string/substr/">substr</a>: <br /><pre class="prettyprint">std::string primer_cifra = ver.substr(0, i);<br /></pre>Esto significa: <em>che vos, función substr, devolveme el pedazo de cadena de caracteres que va desde el índice 0, y tiene una longitud de i-caracteres.</em><br /><br />El proceso puede ser repetido tantas veces como queramos para seguir obteniendo cifras. Por ejemplo, para la siguiente cifra debemos buscar (find) el siguiente punto, pero comenzando desde el que encontramos hace un rato: <br /><pre class="prettyprint">i++;     // ir a la posición siguiente del punto '.'<br />size_t j = ver.find('.', i);<br /></pre><b>¿Qué es (o hace) el segundo argumento de find?</b> Le indica a la función desde donde debe comenzar a buscar. La primera vez que usamos find este argumento no se especificó, porque por omisión toma el valor 0, es decir, buscar desde el inicio de la cadena.<br /><br /><b>¿Por qué i++?</b> Porque si comenzáramos a buscar un punto desde <em>i</em>, nos devolvería la misma posición <em>i</em> (porque justamente, en <em>i</em>, está el primer punto que encontramos). Entonces debemos avanzar una posición.<br /><br />Ahora, debemos recortar la segunda cifra: <br /><pre class="prettyprint">std::string segunda_cifra = ver.substr(i, j-i);<br /></pre>La segunda cifra, comienza desde <em>i</em> y tiene una longitud igual a <em>j-i</em>. Para comprender esto, vea la siguiente figura:<br />
<div class="separator" style="clear: both; text-align: center;"><img border="0" height="155" src="std_string_indices.png" /><br /></div>
<br />De esta forma, <em>ver.substr(i, j-i)</em> nos devuelve la cadena "10". La versión completa del algoritmo puede quedar algo así:<br /><pre class="prettyprint">#include &lt;vector&gt;  // Por std::vector<br />#include &lt;string&gt;  // Por std::string<br />#include &lt;cstdlib&gt; // Por std::strtol<br />#include &lt;cstdio&gt;  // Por std::printf<br /><br />int main()<br />{<br />  std::string ver = "1.10.2.3";<br /><br />  // Vector con cada cifra.<br />  // Luego del procesamiento esto debería ser = { 1, 10, 2, 3 }<br />  std::vector&lt;int&gt; cifras;<br /><br />  size_t i = 0;   // Comenzamos desde i=0<br />  size_t j = 0;<br /><br />  // Repetir hasta no llegar al final de la cadena<br />  while (j != std::string::npos) {<br />    // Buscar próximo punto<br />    j = ver.find('.', i);<br /><br />    std::string cifra;<br /><br />    // Si se encontró un punto<br />    if (j != std::string::npos) {<br />      // Recortamos desde i hasta j<br />      cifra = ver.substr(i, j-i);<br /><br />      // El nuevo comienzo para buscar puntos será "j+1"<br />      i = j+1;<br />    }<br />    // Si no se encontró un punto<br />    else {<br />      // Recortamos desde "i" hasta el final de la cadena<br />      cifra = ver.substr(i);<br />    }<br /><br />    // Obtener el valor entero de la cifra<br />    int cifra_int = std::strtol(cifra.c_str(), NULL, 10);<br /><br />    // Agregar la cifra al vector<br />    cifras.push_back(cifra_int);<br />  }<br /><br />  for (size_t i=0; i&lt;cifras.size(); ++i)<br />    printf("cifras[%d] = %d\n", i, cifras[i]);<br /><br />  return 0;<br />}<br /></pre>La salida del anterior programa es:<br /><pre>cifras[0] = 1<br />cifras[1] = 10<br />cifras[2] = 2<br />cifras[3] = 3<br /></pre>Con este código, podríamos implementar una clase "Version" con la siguiente interfaz:<br /><pre class="prettyprint">class Version<br />{<br />public:<br />  Version(const char*);<br />  Version(const std::string&amp;);<br /><br />  bool operator==(const Version&amp; u) const;<br />  bool operator&lt;(const Version&amp; u) const;<br />  // ...<br />};<br /></pre>En un próximo post voy a colocar una posible implementación de la clase "Version".
</div>
