---
layout: post
title: Excepciones, RAII y auto_ptr
date: 2008-06-24
category: cpp
tags: [cpp, programacion, smart_pointer, exception, leaks, error_handling]
---

<div class='post'>
Una de las mejores formas de realizar un control de errores es por medio de excepciones. Lamentablemente, si no se toman las precauciones adecuadas, se pueden obtener <a href="http://en.wikipedia.org/wiki/Handle_leak">leaks</a> de algunos recursos. Por ejemplo, imagine el siguiente caso:<pre class="prettyprint">int main()<br />{<br /><span> </span><span> </span>try {<br /><span> </span><span> </span><span> </span><span> </span>char *ptr = new char[256];<br /><span> </span><span> </span><span> </span><span> </span>double *matrix = new double[100000*100000]; // 74 Gigabytes<br /><span> </span><span> </span><span> </span><span> </span>// ...<br /><span> </span><span> </span><span> </span><span> </span>delete matrix;<br /><span> </span><span> </span><span> </span><span> </span>delete ptr;<br /><span> </span><span> </span>} catch (const std::bad_alloc&amp; e) {<br /><span> </span><span> </span><span> </span><span> </span>std::cout &lt;&lt; "No hay memoria suficiente" &lt;&lt; std::endl;<br /><span> </span><span> </span>}<br /><span> </span><span> </span>return 0;<br />}<br /></pre>Aquí, con el segundo <em>new</em> una excepción <em>bad_alloc</em> es lanzada. El problema es que la memoria asignada con el primer <em>new</em> nadie la libera. Esto es un <a href="http://en.wikipedia.org/wiki/Memory_leak">memory leak</a>. Una opción para solucionarlo es mediante un bloque <a href="http://www.research.att.com/~bs/bs_faq2.html#finally">finally</a> "a la Java":<br /><pre class="prettyprint">int main()<br />{<br /><span> </span><span> </span>char *ptr = NULL;<br /><span> </span><span> </span>double *matrix = NULL;<br /><span> </span><span> </span>try {<br /><span> </span><span> </span><span> </span><span> </span>ptr = new char[256];<br /><span> </span><span> </span><span> </span><span> </span>matrix = new double[100000*100000];<br /><span> </span><span> </span><span> </span><span> </span>// ...<br /><span> </span><span> </span><span> </span><span> </span>delete matrix;<br /><span> </span><span> </span><span> </span><span> </span>delete ptr;<br /><span> </span><span> </span>} catch (...) { // finally<br /><span> </span><span> </span><span> </span><span> </span>if (matrix) delete matrix;<br /><span> </span><span> </span><span> </span><span> </span>if (ptr) delete ptr;<br /><span> </span><span> </span>}<br /><span> </span><span> </span>return 0;<br />}<br /></pre>Claro que esto no hace al manejo de errores una tarea transparente.<br /><br />En C++ se puede utilizar la técnica <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a> (la adquisición de recursos está en la inicialización), lo que ayuda a evitar <em>leaks</em>. La idea básica detrás de esto es que los constructores obtengan recursos, y los destructores los liberen. Al ocurrir una excepción, se van llamando los destructores de los objetos creados.<br /><br />Para solucionar nuestro problema, podemos utilizar la clase <em>auto_ptr</em> que se encuentra en &lt;memory&gt;. Un <em>auto_ptr</em> guarda un puntero que es liberado automáticamente en el destructor.<pre class="prettyprint">int main()<br />{<br /><span> </span><span> </span>try {<br /><span> </span><span> </span><span> </span><span> </span>std::auto_ptr&lt;char&gt; ptr(new char[256]);<br /><span> </span><span> </span><span> </span><span> </span>std::auto_ptr&lt;double&gt; matrix(new double[100000*100000]);<br /><span> </span><span> </span><span> </span><span> </span>// ...<br /><span> </span><span> </span>} catch (const std::bad_alloc&amp; e) {<br /><span> </span><span> </span><span> </span><span> </span>std::cout &lt;&lt; "No hay memoria suficiente" &lt;&lt; std::endl;<br /><span> </span><span> </span>}<br /><span> </span><span> </span>return 0;<br />}<br /></pre>Los <em>delete</em>s no son necesarios. Al salir del <a href="http://en.wikipedia.org/wiki/Scope_%28programming%29">ámbito</a> del bloque <em>try</em>, ya sea normalmente o por excepción, se llamará al destructor de los <em>auto_ptr</em>s creados, así no se incurre en ningún tipo de <em>leak</em>.<br /><br /><b>Advertencia</b>: Los <em>auto_ptr</em> deben ser utilizados sabiendo cuál es su verdadero funcionamiento: La copia de un <em>auto_ptr</em> a otro no los deja equivalentes. La última copia se queda con el puntero, los demás lo van perdiendo, y el <em>delete</em> lo invoca el último <em>auto_ptr</em> destruido. Por ejemplo:<pre class="prettyprint">{<br /><span> </span><span> </span>std::auto_ptr&lt;Persona&gt; otra_persona;<br /><span> </span><span> </span>{<br /><span> </span><span> </span><span> </span><span> </span>std::auto_ptr&lt;Persona&gt; una_persona(new Persona);<br /><span> </span><span> </span><span> </span><span> </span>otra_persona = una_persona;<br /><span> </span><span> </span><span> </span><span> </span>// ahora "una_persona" apunta a NULL<br /><span> </span><span> </span>}<br />} // aquí la persona es destruida<br /></pre><br /><b>Pregunta</b>: ¿Por qué no usar objetos alojados en el <a href="http://en.wikipedia.org/wiki/Call_stack">stack</a> en vez del <a href="http://en.wikipedia.org/wiki/Dynamic_memory_allocation">heap</a> para evitar los <em>leaks</em>? Porque el <em>stack</em> es mucho más pequeño. Por ejemplo, el siguiente código provoca un <a href="http://en.wikipedia.org/wiki/SIGSEGV">SIGSEGV</a> ya que el arreglo no entra en el <em>stack</em>:<pre class="prettyprint">double matrix[1000000];</pre>Pero sí entra en el <em>heap</em>:<pre class="prettyprint">double *matrix = new double[1000000]; // 7.6 Megabytes</pre>
</div>
