---
layout: post
title: Miembros virtuales
date: 2010-08-30
category: cpp
tags: [cpp, programacion]
---

<div class='post'>
Una <a href="http://en.wikipedia.org/wiki/Virtual_function">función miembro virtual</a> tiene la característica de poder ser sobrecargada por subclases para agregar un comportamiento propio. Pero existen dos lugares en donde las funciones virtuales toman un comportamiento especial: en los constructores y los destructores.<br /><br />Veamos el siguiente ejemplo:<br /><pre class="prettyprint">#include &lt;iostream&gt;<br /><br />using namespace std;<br /><br />class Lugar {<br />public:<br />  Lugar() {                     // El lugar es creado<br />    creacion();                 // Llamamos a la función virtual<br />  }<br />  virtual ~Lugar() {            // El lugar es destruido<br />    destruccion();              // Llamamos a la función virtual<br />  }<br />protected:<br />  virtual void creacion()    { }<br />  virtual void destruccion() { }<br />};<br /><br />class Universo : public Lugar {<br />protected:<br />  void creacion()    { cout &lt;&lt; "Big Bang\n"; }<br />  void destruccion() { cout &lt;&lt; "Big Crunch\n"; }<br />};<br /><br />int main()<br />{<br />  Universo i_am_god;  // ¿Qué imprime este programa?<br />  return 0;<br />}</pre><p>La idea de todo método virtual es poder proporcionar puntos de extensión a las clases derivadas. En este caso, ¿<i>Lugar::creacion</i> funciona como punto de extensión para clases derivadas? La respuesta es: no. El anterior programa no imprime nada.</p><p>Aunque creamos una instancia de <i>Universo</i>, ni el método <i>Universo::creacion</i> ni <i>Universo::destruccion</i> se llamaron. ¿A qué se debe esto? Imaginemos que al crear un <i>Universo</i>, primero debemos crear un <i>Lugar</i> en su totalidad, para luego comenzar a crear el universo. Es por eso que si llamamos a <i>creacion</i> mientras estamos construyendo el <i>Lugar</i>, no podemos alcanzar el método <i>Universo::creacion</i> ya que el <i>Universo</i> todavía no comenzó a ser construido (no tiene un <i>Lugar</i> completamente construido donde existir).</p><p>La secuencia correcta es:</p><ol><li>Alojamos un cacho de memoria suficiente como para que entre el universo.<br />Algo así como hacer un: <i>this = malloc(sizeof(Universo))</i> en C.<br /><li>Construimos el <i>Lugar</i> usando la memoria recién obtenida como puntero <i>this</i>.<br /><li>Luego construimos el <i>Universo</i>.<br /><li>Y recién ahí somos capaces de llamar a <i>Universo::creacion</i> y asegurarnos que estaremos usando el método especializado de la subclase.<br /></ol><p><b>¿Puedo llamar a <i>creacion</i> dentro del constructor de <i>Universo</i>?</b> La respuesta es sí, todo es posible. ¿Es correcto? Mmmhh, depende, si alguien hace una subclase de <i>Universo</i> y sobreescribe <i>creacion</i>, nuevamente estará en el mismo problema que estamos mostrando aquí.</p><p><b>¿Por qué en el destructor de <i>Lugar</i> no llama a <i>Universo::destruccion</i>?</b> Porque el <i>Universo</i> ya está destruido (¿cruncheado?) para cuando llegamos al destructor del <i>Lugar</i>.</p><p><b>¿Cómo lo soluciono?</b> Usar puntos de extensión en los constructores y destructores presentan más problemas que ventajas. La solución es no usarlos. Solución (obvia):</p><pre class="prettyprint">#include &lt;iostream&gt;<br /><br />using namespace std;<br /><br />class Lugar {<br />public:<br />  Lugar() { }<br />  virtual ~Lugar() { }<br />};<br /><br />class Universo : public Lugar {<br />public:<br />  Universo()  { cout &lt;&lt; "Big Bang\n"; }<br />  ~Universo() { cout &lt;&lt; "Big Crunch\n"; }<br />};<br /><br />int main()<br />{<br />  Universo i_am_god;<br />  return 0;<br />}</pre><p>En un próximo post voy a dar un ejemplo más complejo donde esto no sirve.</p><p><b>¿Y qué sucede si llamo una función miembro abstracta en el constructor o destructor?</b> Es el desastre total. Completamente ilegal. Imposible. Una violación absoluta a la razón y el sentido común. Imagine este código:</p><pre class="prettyprint">#include &lt;iostream&gt;<br /><br />using namespace std;<br /><br />class Lugar {<br />public:<br />  Lugar() { creacion(); }        // Ja llamo a creacion()<br />protected:<br />  virtual void creacion() = 0;   // Jaja y no lo defino ;)<br />};<br /><br />class Universo : public Lugar {<br />protected:<br />  void creacion() { }            // Jajaja sólo puede llamarme a mí!<br />};<br /><br />int main()<br />{<br />  Universo i_am_god_x2;<br />  return 0;<br />}</pre><p>Al compilar este código con gcc obtenemos un warning porque estamos llamando un método abstractor en el constructor, y un error de enlace al crear el ejecutable ya que <i>Lugar::creacion</i> no está definido:</p><pre class="console">test.cpp: In constructor 'Lugar::Lugar()':<br />test.cpp:7:22: warning: abstract virtual 'virtual void Lugar::creacion()' called from constructor<br />C:\temp\ccstr9Hr.o:test.cpp:(.text$_ZN5LugarC2Ev[Lugar::Lugar()]+0x16): undefined reference to `Lugar::creacion()'<br />collect2: ld returned 1 exit status<br /></pre><p>Aunque dijimos explícitamente que Lugar::creacion() es abstracto (=0), eso no significa que no debamos definirlo en este caso tan particular.</p><p>Referencias:<br>Sutter, Herb & Alexandrescu, Andrei (2004). Item 49: Avoid calling virtual functions in constructors and destructors. <em>C++ Coding Standards: 101 Rules, Guidelines, and Best Practices.</em> Boston, MA: Addison-Wesley Professional, (ISBN 0321113586).
</div>
