---
layout: post
title: ¿Preincrementar o postincrementar?
date: 2008-08-19
category: cpp
tags: [cpp, programacion, ensamblador, operadores, optimizacion]
---

<div class='post'>
Hace mucho que quería escribir un post tan inútil como este. La duda que siempre me pasaba por la cabeza era la siguiente: ¿Será exactamente el mismo código ensamblador el que genera el compilador cuando utilizamos el preincremento o el postincremento (sin utilizar el valor de retorno)? Tenía la seguridad de que así debía ser (una optimización tan básica no podía ser dejada de lado), pero me faltaban las pruebas (en ensamblador) para verificarlo.<br /><br />Recordando un poco, el preincremento<br /><pre class="prettyprint">int a = 0;<br />int b = ++a;<br /></pre>hace <i>a=1</i> y <i>b=1</i>, mientras que el postincremento<br /><pre class="prettyprint">int a = 0;<br />int b = a++;<br /></pre>hace <i>a=1</i> y <i>b=0</i>, esto significa que <i>b</i> obtuvo el valor de <i>a</i> anterior al incremento.<br /><br />Aquí <i>estamos utilizando</i> el valor de retorno del operador incremento. El código ensamblador <i>es distinto</i> para cada caso. Vamos a echarle una mirada (antes le recomiendo ver <a href="http://www.unixwiz.net/techtips/win32-callconv-asm.html">este excelente artículo</a> para comprender más sobre el stack y las convenciones de llamadas). En el preincremento el código ensamblador (generado por GCC 3.4.5 para i386) es:<br /><pre class="prettyprint">subl  $8, %esp          // reservamos 8 bytes en el <a href="http://en.wikipedia.org/wiki/Call_stack">stack</a> (para variables locales)<br />movl  $0, -4(%ebp)      // a   = 0<br />leal  -4(%ebp), %eax    // eax = &amp;a<br />incl  (%eax)            // *eax= (*eax) + 1<br />movl  -4(%ebp), %eax    // eax = a<br />movl  %eax, -8(%ebp)    // b   = eax<br /></pre>En el postincremento<br /><pre class="prettyprint">subl  $8, %esp          // reservamos 8 bytes en el stack<br />movl  $0, -4(%ebp)      // a   = 0<br />movl  -4(%ebp), %edx    // edx = a<br />leal  -4(%ebp), %eax    // eax = &amp;a<br />incl  (%eax)            // *eax= (*eax) + 1<br />movl  %edx, -8(%ebp)    // b   = edx</pre>donde se ve que el registro edx se utiliza para guardar el valor que tenía <i>a</i> antes del incremento para luego asignárselo a <i>b</i>.<br /><br />Pero la pregunta original es, ¿qué pasa si <b>no</b> usamos el valor de retorno? ¿el código de ++i o i++ es igual? Debería serlo, y de hecho, lo es. Pero como veremos más abajo, esto sólo se cumple si utilizamos tipos de datos <i>built-in</i> (int, double, long, etc.). Miremos el siguiente código:<br /><pre class="prettyprint">void func() { }<br />void pre () { for (int c=0; c&lt;8; ++c) { func(); } }<br />void post() { for (int c=0; c&lt;8; c++) { func(); } }<br />int main()<br />{<br />  pre();<br />  post();<br />  return 0;<br />}<br /></pre>Básico, un <i>for</i> pero con las dos variantes posible de incremento. El código generado para ambos casos (tanto para la función <i>pre</i> como <i>post</i>) es el siguiente:<br /><pre class="prettyprint"><span></span><br />  pushl %ebp              // guardar el viejo puntero a la base del stack<br />  movl  %esp, %ebp        // establecer la nueva base del stack<br />  subl  $4, %esp          // guardar 4 bytes en el stack (para variables locales)<br />  movl  $0, -4(%ebp)      // c = 0<br />L3:<br />  cmpl  $7, -4(%ebp)<br />  jg    L2                // si c &gt; 7 entonces ir a L2<br />  call  _func             // llamar a la función func()<br />  leal  -4(%ebp), %eax    // eax = &amp;c<br />  incl  (%eax)            // *eax= (*eax) + 1<br />  jmp   L3                // repetir yendo a L3<br />L2:<br />  leave                   // restaurar la base del stack (popl %ebp)<br />  ret                     // retornar al punto de llamada<br /></pre>Realmente es indiferente usar cualquiera de los dos tipos de incremento, salvo, en los tipos definidos por el usuario.  C++ ofrece un soporte para tipos de usuario igual a los built-in (bueno, no del todo, pero <a href="http://www.artima.com/cppsource/cpp0xP.html">lo están solucionando</a>). Nos da la posibilidad de sobrecargar los operadores de nuestros propios tipos (clases). Por ejemplo:<br /><pre class="prettyprint">class tipo {<br />  int x;<br />public:<br />  tipo(int y) : x(y) { }<br />  tipo(const tipo&amp; y) : x(y.x) { }<br />  // preincremento<br />  tipo&amp; operator++() {<br />    ++x;<br />    return *this;<br />  }<br />  // postincremento<br />  tipo operator++(int) {<br />    tipo tmp(*this);<br />    ++x;<br />    return tmp;<br />  }<br />  bool operator&lt;(int y) const { return x &lt; y; }<br />};<br /><br />void func() { }<br />void pre()  { for (tipo c=0; c&lt;8; ++c) { func(); } }<br />void post() { for (tipo c=0; c&lt;8; c++) { func(); } }<br /><br />int main()<br />{<br />  post();<br />  return 0;<br />}<br /></pre>No colocaré el código ensamblador por desbordar belleza, pero el código generado en este caso es distinto: cada incremento llama a la función correspondiente a su operador. Esto es debido a que ambas implementaciones varían considerablemente. Por ejemplo, el postincremento necesita de una instancia extra de <i>tipo</i> para poder devolver el anterior valor de <i>this</i>, en cambio, el preincremento devuelve una referencia al mismo <i>this</i> (sin necesidad de hacer una copia).<br /><br />Como dato curioso, algo interesante ocurre al utilizar las optimizaciones del GCC. Si compilamos este último programa con el parámetro -O3, vamos a ver que todas las funciones correspondientes a la clase <i>tipo</i> desaparecen, y todo el código resultantes es <i>inline</i>, dando como resultado un código tan óptimo como si hubiéramos utilizado un <i>int</i> en vez de nuestra clase <i>tipo</i>.<br /><br /><b>¿Cómo obtengo el código ensamblador desde un archivo C/C++?</b><br />Con el compilador <i>gcc</i>, hay que utilizar el parámetro -S: <br /><pre class="console">g++ -S -o archivo.s -c archivo.cpp<br /></pre>En <i>archivo.s</i> queda el código ensamblador (sintaxis <a href="http://www.google.com.ar/search?q=AT%26T+Assembly+Syntax">AT&amp;T</a>).
</div>
