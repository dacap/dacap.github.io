---
layout: post
title: Shared Pointers de C++0x
date: 2010-05-29
category: cpp
tags: [cpp, programacion, cpp0x, smart_pointer, leaks]
---

<div class='post'>
En C usted puede hacer esto:<br /><pre class="prettyprint">#include &lt;stdlib.h&gt;<br /><br />struct Persona { };<br /><br />int main()<br />{<br />  Persona* a = malloc(sizeof(Persona));<br />  free(a);<br />  return 0;<br />}<br /></pre><br />Un ejemplo equivalente en C++:<br /><pre class="prettyprint">class Persona { };<br /><br />int main()<br />{<br />  Persona* a = new Persona();<br />  delete a;<br />  return 0;<br />}<br /></pre><br />Por cada <b>malloc</b> existe un <b>free</b> (al menos que use reallocs), y por cada <b>new</b> existe un <b>delete</b> (y por cada new[] un delete[]).<br /><br /><b>¿Existe una forma por la cual C++ se "entere" que ya no quiero usar un puntero?</b> La respuesta es: No, no existe. C++ no tiene un <a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">garbage collector</a>. Pero existen <a href="http://cmasomenos.blogspot.com/2009/11/punteros-por-ambito-scoped-pointers.html">clases que pueden ayudarnos</a>, como el viejo y tan poco querido <a href="http://cmasomenos.blogspot.com/2008/06/excepciones-raii-y-autoptr.html">auto_ptr</a>, o los mejorados <a href="http://www.google.com/search?q=unique_ptr+Class&btnI=1">unique_ptr</a>, <a href="http://www.google.com/search?q=shared_ptr+Class&btnI=1">shared_ptr</a> y <a href="http://www.google.com/search?q=weak_ptr+Class&btnI=1">weak_ptr</a> del nuevo estándar de C++0x (o el <a href="http://en.wikipedia.org/wiki/C%2B%2B_Technical_Report_1#Smart_pointers">TR1</a>).<br /><br />Un <em>shared pointer</em> es una clase que se encarga de guardar un puntero a un objeto (o tipo de dato), y cuenta la cantidad de referencias que se están haciendo a dicho objeto (es decir, la cantidad de shared pointers que apuntan al mismo objeto). El último shared pointer que se destruya (cuando las referencias llegan a cero), será el encargado de borrar el objeto apuntado (mediante un simple delete).<br /><br />Un ejemplo:<br /><pre class="prettyprint">#include &lt;iostream&gt;<br />#include &lt;memory&gt;  // Aquí debería estar shared_ptr&lt;&gt; (GCC 4.4)<br /><br />using namespace std;<br /><br />class Persona {<br />  int n;<br /><br />public:<br />  Persona(int n) : n(n) {<br />    cout &lt;&lt; "Nace la persona " &lt;&lt; n &lt;&lt; "\n";<br />  }<br /><br />  ~Persona() { <br />    cout &lt;&lt; "Muere la persona " &lt;&lt; n &lt;&lt; "\n";<br />  }<br /><br />  static shared_ptr&lt;Persona&gt; Crear(int n) { <br />    return shared_ptr&lt;Persona&gt;(new Persona(n));<br />  }<br />};<br /><br />int main()<br />{<br />  shared_ptr&lt;Persona&gt; a(new Persona(1));<br />  shared_ptr&lt;Persona&gt; b = Persona::Crear(2);<br />  shared_ptr&lt;Persona&gt; c;<br /><br />  cout &lt;&lt; "--- Aquí ambas personas existen ---\n";<br /><br />  c = a; // Aquí c apunta a la persona 1<br />  b = c; // Ahora b apuntará a la persona 1 (la persona 2 muere porque<br />         // ya no existen referencias a ella)<br /><br />  cout &lt;&lt; "--- Aquí la persona 2 ya no existe ---\n";<br />  <br />  return 0;<br />}        // Aquí muere la persona 1 (a, b, c apuntaban a ella)<br /></pre>La salida del anterior programa es esta:<br /><pre class="console">Nace la persona 1<br />Nace la persona 2<br />--- Aquí ambas personas existen ---<br />Muere la persona 2<br />--- Aquí la persona 2 ya no existe ---<br />Muere la persona 1<br /></pre>Como puede ver, en el anterior programa se llama sólo dos veces a "new Persona" y dos veces al destructor ~Persona. No debemos preocuparnos por usar "delete", el shared_ptr&lt;&gt; hace todo por nosotros.<br /><br /><b>¿Cómo hago para que la clase shared_ptr funcione en VS2008 SP1 Express?</b> Debe definir _HAS_TR1 antes de incluir el archivo &lt;memory&gt;. Ejemplo:<br /><pre class="prettyprint">#ifdef _MSC_VER      // Si estamos usando el compilador de Microsoft<br />  #define _HAS_TR1 1 // Esto hará que se incluyan las clases del TR1 (std::tr1)<br />#endif<br /><br />#include &lt;iostream&gt;<br />#include &lt;memory&gt;<br /><br />using namespace std;<br />#ifdef _MSC_VER<br />  using namespace std::tr1; // para tener shared_ptr&lt;&gt; disponible<br />#endif<br /><br />// Resto del ejemplo...<br /></pre>
</div>
