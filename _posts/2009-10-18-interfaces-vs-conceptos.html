---
layout: post
title: Interfaces vs. Conceptos
date: 2009-10-18
category: cpp
tags: [cpp, programacion, conceptos, interfaces]
---

<div class='post'>
¿Qué son los conceptos? Vamos a ver con un simple ejemplo, cómo podemos hacer una equivalencia entre las conocidas <a href="http://en.wikipedia.org/wiki/Interface_(computer_science)">interfaces</a> y los <a href="http://en.wikipedia.org/wiki/Concept_(generic_programming)">conceptos</a>.<br /><br />Imaginen esta "interfaz" (clase abstracta):<br /><pre class="prettyprint">class IPortero {<br />public:<br />  virtual IPortero() { }<br />  virtual void ir_a_piso(int piso) = 0;<br />  virtual int piso_destino() = 0;<br />};<br /></pre>Tenemos otra clase Ascensor que podemos "personalizar" con nuestro propio portero, así nuestra implementación de portero puede hacer <a href="http://es.wikipedia.org/wiki/Ascensor#Algoritmos_de_Maniobras">lo que se le de la gana</a>:<br /><pre class="prettyprint">class Ascensor {<br />  IPortero* m_portero;<br />public:<br />  Ascensor(IPortero* portero) {<br />    m_portero = portero;<br />  }<br />  void apretaron_boton_en_piso(int piso) {<br />    m_portero->ir_a_piso(piso);<br />    mover_ascensor(m_portero->piso_destino());<br />  }<br />  void mover_ascensor(int piso) { ... }<br />};<br /></pre>Con programación genérica, podemos reformular la interfaz convirtiéndola en un "concepto" y la clase Ascensor en una clase plantilla:<br /><pre class="prettyprint">template&lt;class TipoPortero&gt;<br />class Ascensor {<br />  TipoPortero m_portero;<br />public:<br />  Ascensor() { }<br />  void apretaron_boton_en_piso(int piso) {<br />    m_portero.ir_a_piso(piso);<br />    mover_ascensor(m_portero.piso_destino());<br />  }<br />  void mover_ascensor(int piso) { ... }<br />};<br /></pre>La pregunta es, <em>¿qué demonios es TipoPortero?</em>. La respuesta es sencilla: TipoPortero puede ser cualquier tipo de dato que cumpla los siguientes requisitos:<br /><ul><li>Tenga un constructor por omisión (que se pueda construir un nuevo TipoPortero sin argumentos, o sea, <em>TipoPortero()</em>).<br /><li>Tenga una función miembro <em>TipoPortero::ir_a_piso(int)</em>, la cual recibe un "int" (o cualquier tipo de dato que se pueda construir desde un "int" implícitamente).<br /><li>Y otra función miembro <em>TipoPortero::piso_destino()</em> que devuelve un entero.<br /></ul><p><b>¿Cómo especificamos la "interfaz" o los "requerimientos" de un concepto?</b> Sencillamente no se puede, <a href="http://cmasomenos.blogspot.com/2009/07/c0x-no-va-tener-conceptos.html">C++0x iba a soportar esto</a>, pero ya no. Hoy en día la mejor respuesta es usar algunos comentarios en la clase Ascensor que especifiquen qué espera en sus parámetros de template. En este aspecto se podría decir que IPortero es mejor porque especifica explícitamente lo que el portero tiene que hacer (funciones a implementar, etc.).<p><b>¿Qué ventaja tiene el concepto con respecto a las interfaces?</b> La clase genérica Ascensor ahora tiene el mismo portero adentro suyo (no un puntero a la interfaz). Las llamadas a las funciones miembro <em>ir_a_piso</em> y <em>piso_destino</em> son llamadas directas (no tienen el <a href="http://en.wikipedia.org/wiki/Virtual_method_table#Efficiency">overhead de una llamada a una función virtual</a>).
</div>
